
Общая идея всех модулей такая:
делают проверку, соответствующую своему названию;
в случае успешности проверки кидают один event;
в случае провала проверки кидают другой event;
оба этих event'а задаютс в конфиге.

Имеет смысл сделать их потомком одного модуля,
чтобы в нем определить чтение event'ов и их выкидывание.

Некоторые модули вполне могут выкидывать большее количество
event'ов, в зависимости от своей проверки и типа.
Например, event_by_http_language может выкидывать
[prefered-language-%s], где %s - обозначение языка.

event_if - модули, которые проверяют логическое значение, и выкидывают либо true, либо false.
event_by - модули, которые выкидывают событие с составным кодом из шаблона и каких-либо данных.

event_collector - модуль, который имеет методы force/break. по умолчанию модуль вызовет событие true.
		 однако, если хоть раз был вызван метод break, то будет вызвано событие false.
		 однако, если после метода break хоть раз был вызван force, то будет все-таки true.
		 Через этот метод можно эмулировать простые логические выражения на массы событий:
AND:
	все "необходимые" события никуда не отображаются
	все "мешающие" событие (негатив от необхоимых) идут в break.
OR:
	все "необходимые" событие иду в force.

Черт. Фигня. Нам надо модуль, которые заранее бы знал какие события ему должны прийти.
И если пришли все до единого - выдавал бы true. Это AND.
А если пришло хоть одно из них - выдавал бы true. Это OR.
Но как тогда ловить негативы событий? Методом, отличным от позитива, и делающим все наоборот.

Вообще, вопрос: а оно нам надо?
Наверное, да. Для таких вещей как "запрос http-пути /xyz/ ИЛИ http-url /xyz/" - чтобы вели в один модуль.
Но это можно сделать заданием одного события для разных проверятелей. Так что операция ИЛИ нафиг не нужна.
С другой стороны, этот модуль надо вызвать только один раз, а проверятели могут выкинуть событие несколько раз.
Таким образом, нужен какой-то логический аггрегатор(коллектор) событий. Такими арегаторами могут быть операции
И-авто (выкинуты все операции в успешном ключе), ИЛИ-авто (выкинут хотя бы один успешный событий),
И-список (выкинуты все операции из указанных в списке конфига), ИЛИ-список, и тп.
XOR-авто (операция успеха вызвана тоьлко один раз).




Изначальной целью аггрегаторов была эмуляция поведения call_by_path_0, который не только вызывает определенное
событие под определенным путем, но и проверяет не был ли занят определенный слот. И еще чтобы можно было
создавать ошибку 404 и т.п.

В нашем случае у нас два отдельных проверяльщика: нахождение под путем, и занятость слота. нам нужна операция AND.
	check_http_path_enter	-> [/enter/]   : [!/enter/]
	check_main_slot		-> [main_slot_used] : [main_slot_free]
	check_enter		-> [do-/enter/]
		put_true([/enter/], [main_slot_free])
		put_false([!/enter/], [main_slot_used])

Увы, если путей будет много, то система становится слишком уж навороченной. По три лишних события и по два модуля
на каждый из таких путей (события и модули про слоты остаются общими).
Решением  может быть использование не event_if, а event_by. Выкидывать сообщения типа [we-are-in-/enter/].
Надо тоьлко завязать это на проверку слотов.
Теперь вместо двух вспомогательных модулей (check_http & aggregator) у нас будет тоьлко один (aggregator).
Но все равно это плохо, потому что два модуля на страницу (вспомогательный агрегатор и основной контент)
- это много.



А можно ли как-нибудь решить задачу с занятием слотом с помощью cancelable events? То есть ставить обработчики,
которые при определенных обстоятельствах возвращают non-null, и тем самым прекращают работу события, в том числе
события о выполнении определенного контента? Ставим модуль slot_checker_0. На него вешаем все события [in-/.../],
причем до того, как они попадут в контент-генератор. Модуль, если сконфигурированный слот занят, возвращает false,
тем сам прекращая обработку события, и контент не генерируется. Прелесть :)
Всего два модуля на всю сисиему: event_by_http_path & main_slot_checker. Ну и плюс контент-модули.
!!!!!!!! ТАК И ДЕЛАТЬ !!!!!!!

Ага. Проблема тут в том, что все-таки для каждого контент-модуля придется делать дополнительную запись
в eventhandler'ах о том, что его событие генерации надо сначала заруливать в main_slot_checker. Что тоже
не есть хорошо. А как можно зарулить все сообщения всех контент-модулей через main_slot_checker?
Один из способов таков: делаем в ядре метод events(list), который триггерит все event'ы из списка
(в списке пары <eventid,data>). Если кто-то вернет non-null, то прерывается вся цепочка event'ов.
То есть это блее общий случай единичного event().

С такой системой мы может послать events(contentdetected + /enter/), где первое событие - это общее оповещение
о том, что мы чего-то нашли. Оно направляется в main_slot_checker, который поверяет слот и может отменить
всю цепочку, не доходя до /enter/. Поэтому в списке event handler'ов будет всегда одна запись проверки слота
на любое количество контент-модулей.

Но что будет если у нас много методов проверки какой контент запрошен? например, httppath & httpquery.
Тогда сначала один генерирует событие, и контент-модуль его ловит, и делает контент, и занимает тем самым слот.
Потом второй модуль генерирует событие, но слот-чекер уже не пропускает событие до контент-генератора.
Это, конечно, плохо. Второй детектор не должен бы срабатаывать вообще. А так не получится. Ибо вдруг
там другой контент? А слот-то занят.

Черт, все не так. не в паралель это должно быть. 




Надо чтобы кто-то выкидывал [generate-for-slot-main], и контент-модули уже бы на него реагировали.
Причем только те, которым надо среагировать по критетерию запроса (путь или указание модуля).
И первый среагировавший прерывал бы всю цепочку этого event'а. Но у нас так не сделано, потому что
слоты задуманы как вспомогательно средство, а не основная концепция ядра. Особенно если учесть,
что слот может занять любой другой модуль перед выкидыванием этого event'а. Например, identify...failure.

Таким образом, ничего не остается, кроме псевдопараллельной проверки криетриев и вызова модулей,
блокируя их вызов по критерию занятости слотов. Это означает что все проверки будут таки проведены.
А потом гораздо лучше испоьлзовать _by_ модули, чем _if_, потому как в by проверка всего одна на все
множество модулей (точнее, не проверка, а составление имени события).

Т.о., по ссылке .../index.php/abc/?module=def срабатывание будет таким:
	http_by_path видит /abc/, и генерирует события [want-main-slot]+[work-abc]
		main_slot_checker ловит [want-main-slot] и проверяет слот, но он не занят и оно возвращает null
		content_abc ловит [work-abc] и выводит нужные данные в слот main
	http_by_query видит module=def, и генерирует [want-main-slot]+[work-def]
		main_slot_checker ловит [want-main-slot] и проверяет слот; слот занят и оно возвращает true, тем самым прерывая вызов

Вот так. Если вдруг первый генератор контента ничего не сделает, или не займет слот, или займет не тот слот,
то второй генератор преспокойно сработает как будто он был первым.






























