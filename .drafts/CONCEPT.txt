CORE-N --
	это программная библиотека на языке php(>=5),
	предназначенная для разработки web-сайтов и иных web-продуктов
	по модульно-событийному принципу с использованием ООП, XML, DOM.
	Далее просто "ядро".

Главный файл содержит только всеобще-необходимый класс coren,
а также вызов основного метода срабатывания ядра при необходимости.
Класс coren содержит только статические методы и поля, необходимые для работы
в модулях, а также ряд констант, используемых в вызовах собственных методов.
Методы, доступные модулям, являются public. Другие методы (вспомогательные)
являются только protected, но никогда -- private. Это для возможности наследования
от главного класса в целях модернизации некоторого его поведения в некоторых
проектах (если нет иного пути достижения той же цели).
Все методы, переменные, константы и иные объекты языка задаются в нижнем регистре
с подчеркиваинем вместо пробела, на английском языке, без сокращений,
и чтобы их назначение было достаточно понятно по их названию.

Файлы модулей распологаются в любом каталогах, в которых создатель сайта сочтет нужным.
Главное, чтобы они были доступны механизму include'инга ядра (см. далее).
Имя файла обязательно состоит из собственного названия модуля и числового номера
версии этого модуля. С функциональной точки зрения комлекс имени и версии является
единым идентификатором, и не анализируется. А вот модули управления могут по своему
усмотрению анализировать имя файлы и вычленять из него собственное имя и версию,
а затем сравнивать разные версии одного модуля.
Имя файла должно точно соответствовать имени класса, который в нем определяется.
Соглашения об именовании классов и файлов точно такие же, как и для главного класса.

Методы в ядре принимают параметры обычным спобом (а не именованным хешем, как раньше).
Т.о., порядок параметров становится важен. Впрочем, некоторые модули могут принимать
только один параметр, и использовать его как хеш значений. Решает разрботчик модуля.
Методы, доступные из других модулей или из ядра, должны являться public. Другие методы
могут быть как protected, так и private - как решит разработчик.

Межмодульные вызовы идут исключительно через ядро, чтобы ядро могло отслеживать
какой модуль ныне активен. Это используется при возникновении ошибок и ряде других
случаев. Ряд модулей являются резидентными, то есть их экземпляр создается в любом
случае, даже когда модуль нигде не вызывается явно. Такие модули получают все
широковещательные события и используются в иных массовых функциях ядра, когда список
целевых модулей не указан явно.

На каждой странице должен быть какой-то главный модуль. Чтобы определять какой
модуль должен быть главным (если мы не указываем это в файле index.php в каждом
каталоге), должен быть резидентный модуль, который по запрошенному урлу и/или по
параметрам запроса определит какой модуль главный,и сообщит это ядру. Идея может
быть расширена на то, что на странице может быть не один, а несколько главных модулей.
Хотя гораздо проще сделать эту же функциональность таким образом: один из резидентных
модулей все время заявляет себя как требующий вызова сразу после инициализации ядра.
Ядро, проведя все подготовительные работы, проходит по очереди вызовов. Этот модуль,
будучи вызванным уже из очереди, определяет какой модуль нужно вызвать (на основе
запроса), и вызывает его напрямую. Если ядро на момент генерации контента имеет
пустую очередь вызовов, то оно пробует вызвать дефолтный модуль (задается в конфиге
ядра или в базе конфигов). Если и он не задан, то ядро ничего не выводит, а создает
ошибку что, мол, вывести нечего.




Результатом работы ядра почти всегда является XML-документ. Причем в ядре он существует
в форме DOMDocument, и уже в итоговом выводе обрабатывается XSLT и превращается в текст.
Каждый модуль при работе своих методов возвращает какое-то значение, которое идет тому,
кто этот модуль и метод вызвал. Если вызов происходил от ядра (либо на стадии подготовки
работы, либо на стадии генерации контента), то этот результат, если он DOMNode,
помещается в итоговый накопитель результата. Если это скаляр, то он превращается
в DOMElement, и тоже помещается в результат. Если это массив, то он превращается
в специальную DOM-структуру из DOMElement'ов, и тоже в результат.

Как результат обрабатывается XSLT....

Как .... и тп )














Для конфигурирования ядра создается один или несколько файлов в специальных местах
со специальными именами, которые ядро при запуске читает. В этих файлах содержится
только присвоение ряда переменных, которые потом учтет ядро. Файлы выполняются в
изолированном контексте функции, потому переменные являются локальными для функции.
Допустимо в этих файлах вызывать некоторые методы PHP, задающие его конфигурацию
(на случай, если по какой-либо причине недоступны .htaccess и php.ini).

В конфиге, в частности, задаются основные параметры подключения к базе данных
самого ядра, и имя модуля, который будет выступать базой данных по умолчанию
(если в конфиге какого-то модуля обработчик подключения не задан явно). Если
имя модуля для дефолтного подключения не задано, то в качестве дефолтного
используется подключение самого ядра.

Все прочие параметры для работы: список модулей и их свойства, список конфигов
модулей с их значения, список универсальных всесайтовых конфигов - все это читается
из базы данных ядра. Оно может быть как обычно RDBMS, так и какой-то особой
структурой, например, на диске.

Модуль, который желает выступать в роли подключения к базе данных, обязан обеспечить
методы: _coren_connect(), _coren_disconnect(), _coren_commit(), _coren_rollback),
_coren_read_modules(), _coren_read_configs().


















Механизм include'инга.

