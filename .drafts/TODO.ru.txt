 Модуль сборщика xslt, которые все файлы хранит в одном каталоге с любыми именами. И один главный
 файл-каталогизатор в формате xml, в котором собраны все записи <im,mo,me,id,fo> и соответствующий
 им файл из каталога. То есть этакая база данных в xml формате. И другой модуль, где база не в xml
 формате, а в реальной базе данных хранится. Можно и сами xslt туда же, в базу запихать.

 Сделать неким образом чтобы ряд страниц можно было пометить как требущие обязательной автризации,
 и перекидывающую на страинцуавторизации в таком случае, либо требущих http-авторизацию немедленно.
 Полезно будет для разделения на админские разделы с правами изменеиня и клиентские с правами только
 на чтение, но чтобы без особого использования ролевой модели.

 Сделать так, что если генерируется ошибка 404, то все другие модули (обычно всопогательных боковых данных)
 не должы срабатывать вообще, или должны сработать выборочно. Если выборочно, то вероятнее всего ошибка 404
 должна просто забить некоторые слоты своими псевдоданными. Причем не просто занять их слоты, а именно
 не допустить их выполнения вообще, и даже загрузки (вероятно, с помощью промежуточного слот-чекинга).

 Ввести в ядро режим тишины (полная тишина если модуль берет на себя генерацию контента вплоть до бинарного
 (ранее было shutup); частичная тишина, то есть необходимость прервать сбор данных и вывести все как есть сейчас).
 Режимы тишины делать после того, как будет сделана ошибка 404, потому что как только режим тишины введен,
 другие модули даже не должны срабатывать, а не только не выводиться.

 Модули задания состояния: php_encoding_mb_http_input_0, php_encoding_mb_http_output_0, php_encoding_mb_internal_0...

 Nearest plans:
 	storage*
 	activator*
 	format*
 	imager*
 	logger*
 Then:
 	static_0
 	recurse_0 (file_searcher?)
 After that:
 	list_0 or something like that

 Выправить комментарии в ядре ко всем методам.

 Добавить $Rev и прочие идентифкаторы в файлы (придумать систему где и как вставлять),
 и прописать всем имеющимся файлам свойство о замене этих ид, а всем новым файлам в конфиге
 прописать автовставку этого свойства.

 Сделать чтобы depend() проверяла существование класса и до попытки подгрузить/найти файл.
 Потому что вдруг он уже определен?

 Конфиг сайта в XML файле. Для начала замерить что быстрее - 3-4 запроса в базу, или один XML файл и его DOM-анализ.

 Конфиги модулей не строчками, а вольными тегами внутри метаконфига ядра.

 Конфиг для указания DTD, по которому валидировать результирующий XML. Если не задан - то не валидировать.

 coren::db()->coren::databroker() или coren::data()
 database -> dataformat, datasource, ...

 XML PIs: <?coren-xslt ...?>, которые либо обрабатываются прямо на сервере, либо замещаются <?xsl-stylesheet ?>
 и передаются клиенту. Причемзамещаются с учетом текущего формата вывода (xml, xhtml, ...).


 Заменить везде /*rts*/ self::$rts_count_of_coren['.....']++; на /*rts*/ self::$rts_count_of_coren[__METHOD__]++;
 Даже несмотря на то, что в __METHOD__ вписывается еще и класс. Особенно полезно на случае наследования от coren.
 Хотя можно и __FUNCTION__ поставить вместо него.

 Избавиться от /*err*/ в пользу /*xvc*/ & /*xsc*/.

 Когда файл подключен в режиме DECLARE_ONLY, и вызываются coren-api методы без вызова work, то rts ругается
 на кривые индексы. Сделать так, чтоб rts всегда инициализировался, даже если DECLARE_ONLY. Хотя нужно ли? :/

 Заменить везде термин implementer на class.

 Переименовать grant & have так, чтобы там было слово privilege, а have не использовалось (проблемы с родами: have/has).

 <prefetch-load-class-file/> - чтобы заранее загружать все или только некоторые ссылки на файлы. хотя нафиг?
 только замедлит при реальном поиске.

 Исправить в event(): когда срабатывает маппинг, он портит структуру data для других хандлеров, которым
 этот маппинг и не нужен вовсе. Сделать предварительное сохранение и последующее восстановления $data
 для каждого хандлера.

 An idea: make event not cancelable by returning non-null value (i.e. it continues to cal handlers),
 but make coren_exception_abort_event to contain some data fields, which will be returned as a result.

