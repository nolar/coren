Выявленные недостатки при создании сайта digart.ru
==================================================

1. постоянный редирект картинки с урла ?action=nicon&... ведет к тому,
   что постоянно выполняется скрипт запроса данных от корневого модуля до всех дочерних. это нагружает сервер.
   а IE, например, при смене картинки (rollover) постоянно делает новый запрос к этому урлу.

2. мало возможностей для создания разного дизайна для разных страниц
   (корневой, обычных, выборочных по запросу (например, для картинки через ?id=)).
   ПРОБЛЕМА РЕШЕНА.

3. не полностью отлажен модуль list, а также его наследники. возможны ошибки. особенно в плане работы с файлами.

4. не очень хорошо что storage_dir при каждом поиске файла по идентификатору сканирует каталог на все содержимое,
   хоть и берет тоьлко первый файл. плох сам факт сканирования. имя файла должно бы как-то угадываться.

5. корневая страница сайта не содержит реальных обращений к модулями, а ядро того требует.
   в итоге все что оказывается наработано каким-то модулем, игнорируется.
   ПРОБЛЕМА РЕШЕНА.

6. Отсутствуют пока что оповещательные события в list, которые могли бы перехватываться синхронизаторами.




РЕШЕНИЯ И ИДЕИ
==============

1. Сделать так, чтобы хранилище иконок (nicon. picon) выводило в img.src не ссылку на ?action=nicon&..., а прямую ссылку
   на картинку в хранилище. Каталог хранилища должен при этом быть общедоступен.

   Разные типа хранилища либо выводят прямую ссылку на объект, либо ссылку на главный контент-модуль через ?action=nicon,
   либо сами являются контент-модулями, и выводят ссылку на себя самих, указывая в урле ?id=storageid. При необходиомсти
   ведут учет того, кому и что разрешено смотреть. Например, по сессии. Разрешение запоминается в базе при формировании 
   такой ссылки в хозяйском контент-модуле, а проверяется при ее открытии когда хранилище само является контент-модулем.

   При этом, правда, не пропадает проблема с кешированием и перезапросом в браузерах, но упрощается структура запросов
   к базе в скрипте (вместо чтения элементов от корня до дочерних теперь идет только одно чтение по storageid).



2. Сделать core::envelope(), которая могла бы менять тот шаблон, который будет использован для оборота контента.
   В списке резидентных модулей идет enveloper, который ставит начальный конверт на main.
   Модули в процессе работы могут сгенерировать свой контент, и вызвать core::envelope чтобы сменить конверт на нужный
   им. Скорее всего это будут делать в шаблонах, а не в модулях.
   Любой последующий вызов перекрывает значение предыдущего.
   Вот только вопрос, а могут ли этот метод вызывать не-контентные модули, и контентны, но не не-доминантные?
   Скорее всего могут. А то мы замучаемя проверять доминантность, а в случае с модулем envelope он вообще даже не контентный.

   Еще у нас должен быть модуль envelope_conditional, который ставил бы свой конверт (из конфига) при выполнении условия,
   например что вызвана определенная страница (корневая, т.е. когда DEPTH==0; либо под каталогом /xxx/yyy/*; и тп),
   либо что активным является такой-то модуль (надо только сделать чтобы активность определялась из модулей, а не была
   прероативой ядра; а это крайней проблематично; так что нафиг).

   Эффект подкатложности может быть достигнут установкой простого envelope с заданием activeunder. Такое не пройдет только
   для корневого каталога, так как распространит действие конверта на все дочерние. Как вариант можно усложнить activeunder,
   позволив задавать в ней структурность (* в конце строки означает что угодно, а вот /*/ означает один уровень каталогов);
   тогда у нас можно будет задать envelope для "/" для корневого урла, и envelope же для "/*/" для всех остальных уровней.


4. Модуль хранилища должен не только уметь выдавать урл своего файла, но и выводить его. Еще боьшой вопрос как нужно ссылаться
   на файлы в хранилище. Варианты пока такие:

   а. Как сейчас. То есть мы обращаемся к главному модулю по ?action=image&id=XXX, этот модуль перехватывает action=image,
      и получает урл файла из хранилища и делает редирект на него.
      Минус -- идет постоянный редирект, а значит постоянный запрос к главному контент-модулю и чтение из базы.
      Минус -- отсутствие системы контроля доступа к файлам.

   б. Аналогично, но вместо получеиня урла и редиректа просит модуль вывести контент сохраненного файла. По passthrough().
      Минус -- идет постоянный редирект, а значит постоянный запрос к главному контент-модулю и чтение из базы.
      Минус -- становится невозможна докачка таких файлов, так как все идет через скрипт.

   в. Модуль-хозяин сразу просит урл файла, и выводит его вместо ?action=image. Так или иначе, а файл у нас что в варианте (а),
      что в этом варианте (в) должен быть общедоступных, а потому нет особо смысла делать какие-то постоянные проверки на
      доступности главного элемента, если нам нужно всего-то один файл из хранилища.
      Минус -- отсутствие системы контроля доступа к файлам.

   г. Хранилище само является контент-модулем на другом урле. В полях типа src, href мы выводим ссылку на этот модуль
      с указанием ?id=STORAGEID. Модуль предварительно оповещаем, что вот, мол, собери данные, которые тебе нужны для
      проверки и идентификации юзера. Потому что этому юзеру ты должен будешь отдать файла STORAGEID. Модуль хранилища
      запоминает (ид сессии, ид аккаунта, ип посетителя, или сует свой куки, или еще чего), и выходит (или возвращает урл).
      А при запросе к нему напрямую, он проверяет эти же данные, и если все ок (этому юзеру ранее было разрешено запрашивать
      этот файл), то либо выводит его по passthough(), либо отдает по redirect. Либо вообще формирует временный каталог
      для данного посетителя (в методе оповещения), и возвращает урл на этот каталог. Только все права дотупа прописывает
      в этот каталог в файле .htaccess.
      Минус -- сложность реализации, и пока еще непонятность как делать и как олжно работат.
      Плюс -- предвидимая гибкость хранилища на основе варьирования модуля и его функциональности, без необходимости менять list&ko.



5. Просто сделать что доминантный модуль не указан. И все. Это, во-первых, решит проблему с истечением сессий и т.п., когда
   модуьл перехватывает управление на себя. Он так и скажет в контенте, что сессия истекла, делаем редирект. А если ничего
   никто не перехватил - то мы ничего и не делаем, и передадим конверту content=null.

   Либо можно сделать модуль static_content, которому уазывается файл, в котором лежит контент. Он его просто и банально
   выводит, без всяких проверок и даже без скриптов. Обычно это может быть index.html в том же запрошенном каталоге.
   Или отдельный путь. Максимум что можно сделать - это в конфиг поместить путь+ext, а в параметры (args) - кодовое имя
   контента, и формировать путь как {path}/{codename}.{ext}. Если кодовое имя не указано в параметрах, то указать его
   в default_codename в конфиге.











