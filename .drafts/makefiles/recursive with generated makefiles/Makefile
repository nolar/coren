#################################################################################
#										#
# COREN (a) nolar@numeri.net							#
# Главный makefile всего проекта.						#
#										#
#										#
# Для выполнения команд требуется шелл sh, а также ряд базовых команд (cp,	#
# rm, mv...). Сам makefile работает только в GNU make.				#
# Шелл, команды и GNU make входят в MSYS (http://www.mingw.org/msys.shtml).	#
#										#
# Цели (goals), доступные для make, деляется на две категории: те, которые	#
# можно вызывать только в главном каталоге проекта, и те, которые можно		#
# вызывать как в главном каталоге, так и в каталогах с исходными кодами.	#
# Тем не менее, цели из второй категории (везде доступные) отличаются друг от	#
# друга в зависимости от того, где они были вызваны. Все цели, вызванные	#
# внутри каталогов с исходным кодом, выполняют действие только в этом каталоге,	#
# не осуществляя рекурсивный спуск по подкаталогам. Одноименные цели, вызванные	#
# из главного каталога проекта, кроме своих собственных действий еще и обходят	#
# все каталоги с исходными кодами и вызывают запроенные цели в каждом таком	#
# каталоге. Таким образом, будучи вызванной из главного каталога, эта цель	#
# выполняется целиком для всего проекта.					#
#										#
# Следует отметить также, что в каталогах с исходным кодом любые цели доступны	#
# только если выполнена генерация makefile'ов для этих каталогов (см. цель	#
# makefiles). Пока генерация не выполнена, makefile отсутствует, и выполнять	#
# просто нечего. При выполнении целей главного каталога, которые рекурсивно	#
# проходят по каталогам с исходными кодами, эта цель автоматически выполнится	#
# перед обходом. Если это не разновидность clean, то исполнение такой цели	#
# оставит за собой makefile в каждом каталоге с исходными кодами.		#
#										#
# При разработке, в каталогах с исходными кодами можно создавать файлы		#
# makefile.local, которые читаются при выполнении любых целей в этих каталогах.	#
# В них можно задать дополнительные действия, которые выполняются до и после	#
# выполнения основного действия цели. Для этого нужно определить правило с	#
# именем pre-XXX или post-XXX, где XXX - это имя цели, для которой нужно задать	#
# дополнительные действия. Переопределять другие действия, такие как		#
# all, XXX, do-XXX, не нужно, а точнее нельзя. В то же время, можно создать	#
# свои дополнительные правила, которых нет в основных makefile'ах. Главное -	#
# чтобы их названия не использовались нигде в другом месте.			#
#										#
# Также в файлах makefile.local можно задавать или переопределять значения	#
# переменных основного файла, если в этом есть необходимость. В них же должны	#
# задаваться списки дистрибутивных файлов этого каталога, то есть те файлы,	#
# которые не будут удалены при выполнении цели distclean. Внимание! В файлах	#
# makefile.local список дистрибутивных файлов всегда задавайте через "+=",	#
# а не "="/":=", чтобы не сбросить уже заданные элементы списка. Не забывайте	#
# включать в список дистрибутивных файлов также и названия подкаталогов,	#
# иначе они будут стерты еще до того, как начнется их проверка.			#
#										#
# В makefile.local доступны две дополнительные переменные, которые не заданы	#
# в конфигурационном или общем makefile'ах. Это rootpath и herepath.		#
# Переменная rootpath указывает относительный путь от каталога с исходными	#
# кодами до корневого каталога проекта; состоит из нескольких "..", и всегда	#
# оканчивается на "/". Переменная herepath указывает относительный путь от	#
# корневого каталога проекта до каталога с исходными кодами, в котором		#
# расположен данный makefile.local; состоит из нескольких имен папок и всегда	#
# заканчивается на "/". Конструкция $(rootpath)$(herepath)file всегда указывает	#
# на файл с именем file, находящийся в каталоге makefile.local'а.		#
#										#
#										#
# Доступные цели:								#
#										#
# all										#
#	Как в главном каталоге, так и в каталоге с исходными кодами, это	#
#	функциональный синоним для build, а также цель по умолчанию		#
#	(то есть если в командной строке цель явно не указана).			#
#										#
# makefiles									#
#	Создает во всех каталогов с исходным кодом makefile'ы, которые		#
#	ссылаются на makefile.subdirs в корневом каталоге проекта.		#
#	Созданные таким образом файлы удобно использовать для выполнения	#
#	команды make прямо в дочернем каталоге, причем работа выполняется	#
#	только для файлов и зависимостей этого каталога, без рекурсивного	#
#	обхода дочерних или родительских каталогов.				#
#	Эта цель доступна только в главном каталоге проекта; в каталогах	#
#	с исходным кодом она отсутствует.					#
#										#
# clean										#
#	Если цель вызвана в любом каталоге с исходным кодом, то очищает этот	#
#	каталог от файлов, которые генерируются при выполнении цели build.	#
#	Никакие другие файлы, в том числе создаваемые другими целями, либо	#
#	созданные вручную, не трогаются.					#
#	Если цель вызвана в главном каталоге проекта, то выполняет эту же цель	#
#	в каждом подкаталоге с исходным кодом, рекурсивно вызывая make.		#
#										#
# veryclean									#
#	Если цель вызвана в любом каталоге с исходным кодом, то очищает этот	#
#	каталог от файлов, которые генерируются при выполнении цели build,	# 									#
#	а также от всех файлов, которые подпадают под определение мусорных	#
#	(задается в конфигурационных переменных): резервные копии и т.п.	#
#	Если цель вызвана в главном каталоге проекта, то выполняет эту же цель	#
#	в каждом подкаталоге с исходным кодом, рекурсивно вызывая make.		#
#										#
# distclean									#
#	Если цель вызвана в любом каталоге с исходным кодом, то очищает этот	#
#	каталог от файлов, которые не помечены как дистрибутивные; то есть	#
#	от тех файлов, которые тем или иным способом генерируются при		#
#	выполнении любой цели, которые подпадают под определение мусорных, и	#
#	которые созданны вручную. Это подразумевает и удаление автосозданного	#
#	makefile'а этого каталога (см. цель makefiles), то есть самого себя.	#
#	Будьте внимательны. После выполнения этого действия в каталоге с	#
#	исходным кодом любые другие цели не будут выполняться, так как makefile	#
#	будет уже уничтожен. Потребуется заново вызывать цель makefiles из	#
#	главного каталога проекта, чтобы все заработало.			#
#	Чтобы определенный файл не удалялся при выполнении этой цели, нужно	#
#	занести его имя (или маску имен) в переменную ... в makefile.local.	#
#	Если цель вызвана в главном каталоге проекта, то выполняет эту же цель	#
#	в каждом подкаталоге с исходным кодом, рекурсивно вызывая make.		#
#										#
# build										#
#	Если цель вызвана в любом каталоге с исходным кодом, то компилирует	#
#	и компонует все файлы в этом каталоге, которые хоть как-то можно	#
#	компилировать и компоновать.						#
#	Если цель вызвана в главном каталоге проекта, то выполняет эту же цель	#
#	в каждом подкаталоге с исходным кодом, рекурсивно вызывая make.		#
#										#
# install									#
#	Если цель вызвана в любом каталоге с исходным кодом, то устанавливает	#
#	файлы в целевой каталог, предварительно скомпилировав и скомпоновав их	#
#	(см. цель build). Целевой каталог задается в конфигурации.		#
#	Если цель вызвана в главном каталоге проекта, то выполняет эту же цель	#
#	в каждом подкаталоге с исходным кодом, рекурсивно вызывая make.		#
#										#
# tar/tgz/rar/zip/...								#
#	TODO:									#
#	По задумке, должна сделать архив из установленной копии проекта (см	#
#	цель install), даже если в установленную копию были внесены изменения,	#
#	которых нет в исходном коде; например, конфиги сайта.			#
#										#
# upload									#
#	TODO:									#
#	По задумке, должен загрузить установленную копию на ftp-сервер.		#
#										#
# siteoff/siteon								#
#	TODO:									#
#	По задумке, должны выполнить отключение/включение сайта с выводом	#
#	специального уведомления о том, что сайт отключен (через mod_rewrite).	#
#										#
#################################################################################
#
# Подключаем файлы с общими целями и переменными (в т.ч. конфигурационными).
#
include Makefile.config
include Makefile.common
#
#################################################################################
#
# Собираем имена всех подкаталогов в папке исходных кодов, начиная от ее корня,
# и до уровня вложенности 10. Если требуется еще глубже - допишите маски.
# Путь к папке, в которой лежат исходные коды, задается переменной srcdir.
# Этот список используется во многих командах для обхода дочерних каталогов.
#
srcdirs := $(sort $(filter %/,$(wildcard \
	$(srcdir) \
	$(srcdir)*/ \
	$(srcdir)*/*/ \
	$(srcdir)*/*/*/ \
	$(srcdir)*/*/*/*/ \
	$(srcdir)*/*/*/*/*/ \
	$(srcdir)*/*/*/*/*/*/ \
	$(srcdir)*/*/*/*/*/*/*/ \
	$(srcdir)*/*/*/*/*/*/*/*/ \
	$(srcdir)*/*/*/*/*/*/*/*/*/ \
	$(srcdir)*/*/*/*/*/*/*/*/*/*/ \
)))
#
#################################################################################
#
# Вычисление списка файлов разного типа и назначения.
#
# trashfiles - все существующие файла каталога, сочтенные мусорными.
# distfiles  - все существующие файлы каталога, сочтенные дистрибутивными.
# okeyfiles  - все существующие файлы каталога, сочтенные не-мусорными.
# nonefiles  - все существующие файлы каталога, сочтенные не-дистрибутивными.
#
# Насильно дозаполняем список дистрибутивных масок этого каталога, потому как
# больше его негде заполнять (makefile.local для корневого каталога не
# предусмотрен).
#
distlist   += Makefile Makefile.common Makefile.config Makefile.subdir src 1
trashfiles := $(wildcard $(trashlist))
distfiles  := $(wildcard $(distlist) )
okeyfiles  := $(filter-out $(trashfiles),$(wildcard *))
nonefiles  := $(filter-out $(distfiles) ,$(wildcard *))
#
#################################################################################
#
# Определяем цели do-*, которые должны выполнить запрошенную цель в подкаталогах.
# При этом передаем в рекурсивный make не цель do-XXX, а непосредственно XXX.
# Кроме того, делаем так, чтобы do-* не выполнялось, пока не будут сгенерированы
# makefile'ы во всех каталогах, в которых оно будет работать.
# Если какой-то из рекурсивных make'ов вышел с ошибкой, отлавливаем эту ошибку
# и с ней же выходим сами. Это нужно чтобы ошибки в подкаталогах прекращали
# выполнение всего процесса, как это и положено в makefile'ах. Если ошибку
# не перехватывать, то сломавшийся make выводит свою ошибку, а цикл дальше
# продолжает работу по другим каталогам.
#
$(addprefix do-,$(recursivegoals)) : makefiles
ifeq (,$(srcdirs))
	@$(call error_no_srcdirs,$(patsubst do-%,%,$@))
else
	for dir in $(srcdirs) ; do if [ -d $${dir} ] ; then \
		$(MAKE) -C $${dir} $(patsubst do-%,%,$@) ; \
		status=$${?} ; if [ $${status} -ne 0 ] ; then exit $${status} ; fi ; \
	fi ; done
endif
#
#################################################################################
#
# Для целей, которые распространяются на подкаталоги, задаем действия,
# свойственные только корневой папке.
#
post-clean:
#
#
#
post-veryclean:
ifneq (,$(trashfiles))
	-$(RM) -r -- $(trashfiles)
endif
#
#
#
post-distclean:
ifneq (,$(trashfiles))
	-$(RM) -r -- $(trashfiles)
endif
ifneq (,$(nonefiles))
	-$(RM) -r -- $(nonefiles)
endif
#
#################################################################################
#
# Цель makefiles.
# На самом деле, можно ее сделать как множество целей src/every/dir/Makefile,
# и все собрать воедино как зависимость цели makefiles. Тогда у нас и
# параллелизм улучшится, и цели будут доделываться только если они отсутствуют.
# Но сейчас проще и быстрее генерировать их все скопом, одним скриптом.
# Реально быстрее чем генерирование каждого makefile'а по отдельности.
#
makefiles:
ifeq (,$(srcdirs))
	@$(call error_no_srcdirs,$@)
else
	for dir in $(srcdirs) ; do \
		tmp="/$${dir}"; \
		lvl="" ; \
		while [ "$$tmp" != "/" ] ; do \
			tmp="$${tmp%\/*\/}/" ; \
			lvl="../$${lvl}" ; \
		done ; \
		echo "Generating '$${dir}Makefile'..." ;\
		{ \
			echo "# Autogenerated makefile. Do not modify." ; \
			echo "override rootpath := $${lvl}" ; \
			echo "override herepath := $${dir}" ; \
			echo "include $${lvl}Makefile.subdir" ; \
		} > $${dir}Makefile ; \
	done
endif
#
#################################################################################
#
# Цели tar/tgz/rar/zip.
# TODO later.
#
tar:
tgz:
rar:
zip:
#
#################################################################################
#
# Вспомогательные определения сообщений, макросов, функций и псевдо-целей.
#
define error_no_srcdirs
	{ \
		echo "No source directories found for recursion. Sorry." ; \
		echo "It may be either because of wrong current directory (must to be in root package dir)," ; \
		echo "or because of corrupted package (refetch it, re-unpack, or fix manually)." ; \
	}
endef
#
# Цели, которые определяются только в этом makefile'е (то есть отсутствуют в
# makefile.common), и которые являются phony.
#
.PHONY: makefiles tar tgz rar zip
#
#################################################################################
# FIN.										#
#################################################################################
