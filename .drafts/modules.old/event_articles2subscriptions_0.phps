<?php defined('CORENINPAGE') or die('Hack!');
//??? просто комментарий и мысли:
// модуьл по задумке должен ловить сообщения от articles_0, переструктурировать их в группу subject+message+headers,
// и запихивать эту троицу в рассылки (не в мейлер, а в рассылки). т.о., у него должен быть конфиг:
// 1) о том, от какого модуля ловить сообщения (news/events/papers)
// 2) в какой модуль кидать рассылку
// 3) с каким идентификатором рассылки его туда кидать
// Всего в памяти должно висеть три таких слушателя, и каждый отлавливает сообщения от своего модуля-источника.
// Либо же модуль такой один, но имеет внутреннюю таблицу соответствий "исходный модуль<=>код рассылки". Но
// так как с таким конфигом будет заморочно, проще сделать три разных слушателя.

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class event_articles2subscriptions_0 extends module
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

protected $source_module;
protected $target_module;
protected $target_subscription;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function __construct ($configs)
{
	parent::__construct($configs);

	$this->source_module = core::find_scalar(array($configs), array('source_module'), null);
	$this->target_module = core::find_scalar(array($configs), array('target_module'), null);
	if (!isset($this->source_module)) throw new exception('misconfig: source_module');
	if (!isset($this->target_module)) throw new exception('misconfig: target_module');

	$this->target_subscription = core::find_scalar(array($configs), array('target_subscription'), null);
	if (!isset($this->target_subscription)) throw new exception('misconfig: target_subscription');
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function core_event ($args)
{
	 if (($args['executor'] == 'articles_0') && ($args['module'] == $this->source_module))
	 {
	 	$evid = $args['identifier'];
	 	$data = $args['data'];

	 	if (($evid == 'exec_item_success') && ($data['itemold']['published'] == 0) && ($data['itemnew']['published'] == 1))
	 	{
	 		// А еще нужно проверить имеет ли конкрентный подписчик право видеть эту запись,
	 		// основываясь на категории свежедобавленной записи. Однако же, хоть мы и можем
	 		// проконтроллировать текущего посетителя на доступ к записи, но мы никак не можем
	 		// проконтроллировать подписчиков в подписках. Вообще не можем, даже по идее.
	 		// Потому в рассылке должна быть не сама новость, а только извещение о ней со ссылкой на нее.
	 		// А для этого нужны шаблоны у этого модуля, чтобы сформировать извещение о внесении новой записи.

	 		$subject = core::template('subject', array('itemid'=>$data['itemid']));
	 		$message = core::template('message', array('itemid'=>$data['itemid']));
	 		$headers = core::template('headers', array('itemid'=>$data['itemid']));

	 		core::call($this->target_module, 'exec_item', array(
	 			'action' => 'sendnow',
	 			'itemid' => $this->target_subscription,
	 			'submit' => array(
	 				'.subject' => $subject,
	 				'.message' => $message,
	 				'.headers' => $headers)));

	 	}
	 }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}

?>